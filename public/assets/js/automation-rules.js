// X-Ear CRM Automation Rules Engine

// Automation Rules Manager
const AutomationRules = {
  // Core automation rules as defined in specs
  rules: [
    {
      id: "no_show_recovery",
      name: "No-Show Recovery",
      priority: "high",
      enabled: true,
      when: (patient, context) => {
        const lastAppointment = context.getLastAppointment(patient.id);
        if (!lastAppointment) return false;
        
        return lastAppointment.status === "no_show" ||
               (lastAppointment.status === "scheduled" && 
                context.minutesPast(lastAppointment.dateTime) > 15);
      },
      then: (patient, context) => {
        // Tag patient
        context.addTag(patient.id, "no_show");
        
        // Create task
        context.createTask({
          assignee: "reception",
          dueDate: context.addDays(new Date(), 1),
          title: "Rebook no-show patient",
          description: `Patient ${patient.name} missed appointment. Follow up for rescheduling.`,
          patientId: patient.id,
          type: "follow_up"
        });
        
        // Send SMS
        context.sendSMS(patient.id, "no_show_reschedule", {
          name: patient.name,
          reschedule_link: `${context.baseUrl}/appointments.html?patient=${patient.id}&reschedule=true`
        });
        
        // Add to segment
        context.addToSegment("no_show", patient.id);
        
        return {
          success: true,
          actions: ["tagged", "task_created", "sms_sent", "segmented"]
        };
      }
    },
    
    {
      id: "trial_price_no_sale",
      name: "Trial + Price Given → No Sale Follow-up",
      priority: "high",
      enabled: true,
      when: (patient, context) => {
        return patient.deviceTrial && 
               patient.priceGiven && 
               !patient.purchased && 
               context.daysSince(patient.trialDate) >= 7;
      },
      then: (patient, context) => {
        // Tag as high priority
        context.addTag(patient.id, "high_priority");
        
        // Create follow-up task
        context.createTask({
          assignee: "sales",
          dueDate: context.addHours(new Date(), 48),
          title: "Follow up: trial + price given, no sale",
          description: `High priority: Patient ${patient.name} tried device and received pricing but hasn't purchased yet.`,
          patientId: patient.id,
          type: "sales_follow_up",
          priority: "high"
        });
        
        // Add to priority segment
        context.addToSegment("tried_not_purchased", patient.id);
        
        // Schedule reminder SMS
        context.scheduleSMS(patient.id, "trial_followup", {
          name: patient.name,
          device_model: patient.trialDevice || "hearing aid"
        }, context.addDays(new Date(), 1));
        
        return {
          success: true,
          actions: ["tagged_priority", "task_created", "segmented", "sms_scheduled"]
        };
      }
    },
    
    {
      id: "post_purchase_controls",
      name: "Post-Purchase Clinical Controls",
      priority: "medium",
      enabled: true,
      when: (patient, context) => {
        return patient.purchased && 
               patient.deviceType === "hearing_aid" &&
               !context.hasControlAppointments(patient.id);
      },
      then: (patient, context) => {
        const controlDays = [30, 90, 180];
        const purchaseDate = new Date(patient.purchaseDate);
        
        controlDays.forEach(days => {
          // Create control appointment
          const controlDate = context.addDays(purchaseDate, days);
          context.createAppointment({
            patientId: patient.id,
            type: "control_visit",
            scheduledDate: controlDate,
            duration: 30,
            clinician: patient.assignedClinician || "default",
            notes: `${days}-day control for ${patient.deviceModel || 'hearing aid'}`,
            autoGenerated: true
          });
          
          // Schedule reminder SMS
          const reminderDate = context.addDays(controlDate, -1);
          context.scheduleSMS(patient.id, "control_reminder", {
            name: patient.name,
            device_model: patient.deviceModel || "hearing aid",
            appointment_time: context.formatTime(controlDate),
            confirm_link: `${context.baseUrl}/appointments.html?confirm=${patient.id}`
          }, reminderDate);
        });
        
        return {
          success: true,
          actions: ["appointments_created", "reminders_scheduled"]
        };
      }
    },
    
    {
      id: "battery_renewal_reminder",
      name: "Annual Battery Report Renewal",
      priority: "medium",
      enabled: true,
      when: (patient, context) => {
        return patient.batteryReportDue && 
               context.daysUntil(patient.batteryReportDue) <= 30 &&
               context.daysUntil(patient.batteryReportDue) >= 0;
      },
      then: (patient, context) => {
        // Tag patient
        context.addTag(patient.id, "battery_due");
        
        // Create task
        context.createTask({
          assignee: "clinic",
          dueDate: context.addDays(new Date(), 1),
          title: "Process battery report renewal",
          description: `Battery report renewal due for ${patient.name} on ${context.formatDate(patient.batteryReportDue)}`,
          patientId: patient.id,
          type: "sgk_process"
        });
        
        // Send SMS reminder
        context.sendSMS(patient.id, "battery_renewal", {
          name: patient.name,
          booking_link: `${context.baseUrl}/appointments.html?patient=${patient.id}&type=battery_renewal`
        });
        
        return {
          success: true,
          actions: ["tagged", "task_created", "sms_sent"]
        };
      }
    },
    
    {
      id: "overdue_installment",
      name: "Overdue Installment Recovery",
      priority: "high",
      enabled: true,
      when: (patient, context) => {
        return patient.installments && 
               patient.installments.some(installment => 
                 !installment.paid && new Date(installment.dueDate) < new Date()
               );
      },
      then: (patient, context) => {
        const overdueInstallments = patient.installments.filter(i => 
          !i.paid && new Date(i.dueDate) < new Date()
        );
        
        // Tag patient
        context.addTag(patient.id, "overdue");
        
        // Send payment reminder SMS
        context.sendSMS(patient.id, "payment_overdue", {
          name: patient.name,
          amount: context.formatCurrency(overdueInstallments.reduce((sum, i) => sum + i.amount, 0)),
          payment_link: `${context.baseUrl}/payments.html?patient=${patient.id}`
        });
        
        // Create task if overdue > 14 days
        const oldestOverdue = Math.max(...overdueInstallments.map(i => 
          context.daysSince(i.dueDate)
        ));
        
        if (oldestOverdue > 14) {
          context.createTask({
            assignee: "finance",
            dueDate: context.addDays(new Date(), 1),
            title: "Overdue payment follow-up",
            description: `Patient ${patient.name} has ${overdueInstallments.length} overdue installments (${oldestOverdue} days old)`,
            patientId: patient.id,
            type: "payment_follow_up",
            priority: "high"
          });
        }
        
        return {
          success: true,
          actions: ["tagged", "sms_sent", oldestOverdue > 14 ? "task_created" : null].filter(Boolean)
        };
      }
    },
    
    {
      id: "sgk_report_tracking",
      name: "SGK Report Status Tracking",
      priority: "medium",
      enabled: true,
      when: (patient, context) => {
        return (patient.deviceReportRequired || patient.batteryReportRequired) &&
               patient.sgkStatus !== "paid";
      },
      then: (patient, context) => {
        // Check if stuck in pending
        if (patient.sgkStatus === "pending" && 
            context.daysSince(patient.sgkSubmittedDate) > 10) {
          
          context.createTask({
            assignee: "admin",
            dueDate: new Date(),
            title: "SGK report stuck - follow up required",
            description: `SGK report for ${patient.name} has been pending for ${context.daysSince(patient.sgkSubmittedDate)} days`,
            patientId: patient.id,
            type: "sgk_follow_up",
            priority: "medium"
          });
        }
        
        // Check approaching deadlines
        if (patient.sgkDeadline && context.daysUntil(patient.sgkDeadline) <= 7) {
          context.createTask({
            assignee: "admin",
            dueDate: new Date(),
            title: "SGK deadline approaching",
            description: `SGK deadline for ${patient.name} is in ${context.daysUntil(patient.sgkDeadline)} days`,
            patientId: patient.id,
            type: "sgk_deadline",
            priority: "high"
          });
        }
        
        return {
          success: true,
          actions: ["sgk_monitoring"]
        };
      }
    },
    
    {
      id: "five_year_renewal",
      name: "Five-Year Device Renewal Campaign",
      priority: "medium",
      enabled: true,
      when: (patient, context) => {
        if (!patient.purchaseDate) return false;
        const daysSincePurchase = context.daysSince(patient.purchaseDate);
        return daysSincePurchase >= (5 * 365 - 60) && // 60 days before 5 year mark
               daysSincePurchase <= (5 * 365 + 30) &&  // 30 days after 5 year mark
               !patient.renewalContactMade;
      },
      then: (patient, context) => {
        // Create renewal task
        context.createTask({
          assignee: "sales",
          dueDate: context.addDays(new Date(), 3),
          title: "5-year device renewal opportunity",
          description: `${patient.name} is eligible for device renewal. Original purchase: ${context.formatDate(patient.purchaseDate)}`,
          patientId: patient.id,
          type: "renewal_opportunity"
        });
        
        // Send renewal SMS
        context.sendSMS(patient.id, "device_renewal", {
          name: patient.name,
          catalog_link: `${context.baseUrl}/catalog.html?patient=${patient.id}`,
          years_since: Math.floor(context.daysSince(patient.purchaseDate) / 365)
        });
        
        // Mark contact made
        context.updatePatient(patient.id, { renewalContactMade: true });
        
        return {
          success: true,
          actions: ["task_created", "sms_sent", "patient_updated"]
        };
      }
    }
  ],

  // Rule execution context
  createContext() {
    return {
      baseUrl: window.location.origin,
      
      // Date utilities
      addDays: (date, days) => {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
      },
      
      addHours: (date, hours) => {
        const result = new Date(date);
        result.setHours(result.getHours() + hours);
        return result;
      },
      
      daysSince: (date) => {
        return Math.floor((new Date() - new Date(date)) / (1000 * 60 * 60 * 24));
      },
      
      daysUntil: (date) => {
        return Math.floor((new Date(date) - new Date()) / (1000 * 60 * 60 * 24));
      },
      
      minutesPast: (dateTime) => {
        return Math.floor((new Date() - new Date(dateTime)) / (1000 * 60));
      },
      
      formatDate: (date) => Utils.formatDate(date),
      formatTime: (date) => new Date(date).toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' }),
      formatCurrency: (amount) => Utils.formatCurrency(amount),
      
      // Patient operations
      updatePatient: (patientId, updates) => {
        return PatientManager.updatePatient(patientId, updates);
      },
      
      addTag: (patientId, tag) => {
        const patient = PatientManager.getPatient(patientId);
        if (patient) {
          const tags = patient.tags || [];
          if (!tags.includes(tag)) {
            tags.push(tag);
            PatientManager.updatePatient(patientId, { tags });
          }
        }
      },
      
      // Appointment operations
      getLastAppointment: (patientId) => {
        const appointments = AppointmentManager.getAppointmentsByPatient(patientId);
        return appointments.sort((a, b) => new Date(b.date + ' ' + b.time) - new Date(a.date + ' ' + a.time))[0];
      },
      
      hasControlAppointments: (patientId) => {
        const appointments = AppointmentManager.getAppointmentsByPatient(patientId);
        return appointments.some(apt => apt.type === 'control_visit');
      },
      
      createAppointment: (appointmentData) => {
        return AppointmentManager.addAppointment(appointmentData);
      },
      
      // Task operations
      createTask: (taskData) => {
        const task = {
          id: Utils.generateId(),
          ...taskData,
          status: 'pending',
          createdAt: new Date().toISOString(),
          createdBy: 'automation'
        };
        
        // Add to notifications as task
        NotificationManager.add({
          type: 'task',
          title: taskData.title,
          message: taskData.description,
          patientId: taskData.patientId,
          assignee: taskData.assignee,
          priority: taskData.priority || 'medium',
          dueDate: taskData.dueDate
        });
        
        return task;
      },
      
      // SMS operations
      sendSMS: (patientId, templateId, variables = {}) => {
        const patient = PatientManager.getPatient(patientId);
        if (!patient) return false;
        
        const template = SMS_TEMPLATES[templateId];
        if (!template) return false;
        
        let message = template;
        Object.entries(variables).forEach(([key, value]) => {
          message = message.replace(new RegExp(`{${key}}`, 'g'), value);
        });
        
        // Simulate SMS sending
        console.log(`SMS to ${patient.name} (${patient.phone}):`, message);
        
        // Log communication
        const communication = {
          id: Utils.generateId(),
          patientId: patientId,
          type: 'sms',
          direction: 'outbound',
          content: message,
          templateId: templateId,
          status: 'sent',
          timestamp: new Date().toISOString(),
          automated: true
        };
        
        // Add to patient's communication history
        const patient_comms = patient.communications || [];
        patient_comms.push(communication);
        PatientManager.updatePatient(patientId, { communications: patient_comms });
        
        return communication;
      },
      
      scheduleSMS: (patientId, templateId, variables = {}, sendDate) => {
        // In a real implementation, this would schedule the SMS
        // For now, we'll just log it
        console.log(`SMS scheduled for ${sendDate}: ${templateId} to patient ${patientId}`);
        
        return {
          id: Utils.generateId(),
          patientId,
          templateId,
          variables,
          sendDate,
          status: 'scheduled'
        };
      },
      
      // Segment operations
      addToSegment: (segmentName, patientId) => {
        const patient = PatientManager.getPatient(patientId);
        if (patient) {
          PatientManager.updatePatient(patientId, { segment: segmentName });
        }
      }
    };
  },

  // Execute all applicable rules for a patient
  executeRulesForPatient(patient) {
    const context = this.createContext();
    const results = [];
    
    this.rules.forEach(rule => {
      if (!rule.enabled) return;
      
      try {
        if (rule.when(patient, context)) {
          const result = rule.then(patient, context);
          results.push({
            ruleId: rule.id,
            ruleName: rule.name,
            patient: patient.id,
            executed: true,
            result: result
          });
          
          console.log(`Automation rule executed: ${rule.name} for patient ${patient.name}`);
        }
      } catch (error) {
        console.error(`Error executing rule ${rule.id}:`, error);
        results.push({
          ruleId: rule.id,
          ruleName: rule.name,
          patient: patient.id,
          executed: false,
          error: error.message
        });
      }
    });
    
    return results;
  },

  // Execute rules for all patients
  executeAllRules() {
    const results = [];
    
    AppState.patients.forEach(patient => {
      const patientResults = this.executeRulesForPatient(patient);
      results.push(...patientResults);
    });
    
    // Show summary
    const executedCount = results.filter(r => r.executed).length;
    const errorCount = results.filter(r => !r.executed).length;
    
    Utils.showToast(
      `Automation completed: ${executedCount} rules executed, ${errorCount} errors`,
      errorCount > 0 ? 'warning' : 'success'
    );
    
    return results;
  },

  // Run automation on schedule (daily)
  runDailyAutomation() {
    console.log('Running daily automation...');
    const results = this.executeAllRules();
    
    // Store automation log
    const log = {
      timestamp: new Date().toISOString(),
      type: 'daily',
      results: results,
      summary: {
        totalPatients: AppState.patients.length,
        rulesExecuted: results.filter(r => r.executed).length,
        errors: results.filter(r => !r.executed).length
      }
    };
    
    Storage.save('automation_logs', [
      ...(Storage.load('automation_logs') || []).slice(-30), // Keep last 30 logs
      log
    ]);
    
    return log;
  }
};

// SMS Templates
const SMS_TEMPLATES = {
  no_show_reschedule: "Merhaba {name}, bugünkü randevunuzu kaçırdınız. 10 saniyede yeni randevu alın: {reschedule_link}",
  trial_followup: "Merhaba {name}, {device_model} deneme süreciniz nasıl gidiyor? Uygun fiyat seçenekleri ve finansman için 1'e basarak geri arayın.",
  control_reminder: "Merhaba {name}, {device_model} kontrol randevunuz yarın saat {appointment_time}. Onaylayın: {confirm_link}",
  battery_renewal: "Merhaba {name}, yıllık pil raporunuz yaklaşıyor. Randevu alın: {booking_link}",
  payment_overdue: "Hatırlatma: {amount} tutarında vadesi geçen taksit bulunmaktadır. Güvenli ödeme: {payment_link}",
  device_renewal: "{years_since} yıl önce aldığınız cihazın yenileme zamanı geldi. Yeni teknolojileri keşfedin: {catalog_link}"
};

// Auto-run daily automation (in a real app, this would be triggered by a scheduler)
if (typeof window !== 'undefined') {
  // Check if we should run automation (once per day)
  const lastRun = Storage.load('last_automation_run');
  const today = new Date().toDateString();
  
  if (!lastRun || lastRun !== today) {
    // Run after a short delay to ensure everything is loaded
    setTimeout(() => {
      AutomationRules.runDailyAutomation();
      Storage.save('last_automation_run', today);
    }, 2000);
  }
}

// Export for global access
window.AutomationRules = AutomationRules;
window.SMS_TEMPLATES = SMS_TEMPLATES;
